/**
 * @author Arwed Mett
 */

#ifndef THESEUS_MAP_LAYER
#define THESEUS_MAP_LAYER
#include "../gameobjects/room.hpp"
#include "../gameobjects/brick.hpp"
#include "../gameobjects/floor.hpp"
#include <SFML/Graphics.hpp>
#include <vector>
#include <iostream>
#include "level-description.hpp"
#include "../engine/components/position.hpp"

namespace theseus {
namespace map {
	enum Direction {
		NORTH = 0,
		EAST = 1,
		SOUTH = 2,
		WEST = 3
	};
	enum FieldStatus {
		FREE,
		OCCUPIED, //A brick will be placed here.
		VERTICAL_RESTRICTED, //No Vertical brick can be placed on the field
		HORIZONTAL_RESTRICTED, //No horizontal bick can be placed on the field
		RESTRICTED //This field is reserved, so no object (brick) can be placed on it.
	};
	class Layer;
	std::ostream& operator<<(std::ostream&, const Layer&);

	/**
	 * A Layer is a generator for game objects.
	 * It will create a labyrinth by a given LevelDescription.
	 */
	class Layer {
		private:
			/**
			 * A Metrix representation to memorize the state of a certain field.
			 * A Field can have the status specified in theseus::map::FieldStatus
			 */
			std::vector<std::vector<FieldStatus> > layer;

			/**
			 * Stores the gameobjects which will be added to the generated scene.
			 */
			std::vector<std::unique_ptr<theseus::engine::GameObject> > gameobjects;

			/**
			 * A container to save the floors around a room.
			 * These floors can only be determined while the room is generated.
			 * So this vector stores them, that the can be generated after the walls are generated.
			 */
			std::vector<sf::Vector2<int> > memorizedCorridorFloors;

			/**
			 * Draw a line on the this->layer matrix by a given field status.
			 * This is a helper method.
			 */
			int drawLine(int x, int y, Direction direction, int length, FieldStatus status);

			/**
			 * Creates bricks by evaluating this->layer.
			 */
			void generateGameObjectField();

			/**
			 * Adds a door by a given area.
			 * Usually the area is the rectangle of a room.
			 */
			void addDoor(int x, int y, int width, int height);

			/**
			 * Creates a floor and adds it to this->gameobjects.
			 * It also determines the size of the floor.
			 */
			void setFloor(int x, int y, theseus::gameobjects::FloorType);

			/**
			 * Puts GO's randomly on the map and ensures that the will
			 * not end up in a wall.
			 */
			void populateGameObjects(std::vector<std::unique_ptr<theseus::engine::components::Positionable> >);

			/**
			 * Puts GO's randomly on a certain area of the map.
			 * It ensures that the will not end up in a wall.
			 */
			void populateGameObjects(std::vector<std::unique_ptr<theseus::engine::components::Positionable> >,
					sf::Vector2<int>, sf::Vector2<int>);

			/**
			 * This function tries to generate rooms and put them on the layer.
			 * It tries to ensure that the are placed on the map.
			 * Still if there are too many it will not be able and call an asertion.
			 * If you use this function please consider a proper amount of testing or make the layer large enough.
			 */
			void populateRoomObjects(std::vector<std::unique_ptr<RoomDescription> >);

			/**
			 * returns all GO's which have been generated by the layer.
			 */
			std::vector<std::unique_ptr<theseus::engine::GameObject> > getGameObjects();

			/**
			 * Places randomly rooms on the layer.
			 * This method cannot ensure that all rooms are placed.
			 */
			void fillWithRooms(sf::Vector2<int> minSize, sf::Vector2<int> maxSize, int numWalls);

			/**
			 * This is a helper method to add a room to this->layer and generate an GO.
			 * if the room cannot be placed it will be skipped.
			 */
			void addRoom(int x, int y, int width, int height);

			/**
			 * This is a helper method to add a room to this->layer and generate an GO.
			 * Should be used carefully. Only call this method of you know that nothing is on the area.
			 */
			void forceAddRoom(int x, int y, int width, int height);

			/**
			 * Check if a restricted field is in an area on the layer.
			 */
			bool checkField(int x, int y, int width = 1, int height = 1);

			/**
			 * Clears this->layer of all restrictions.
			 */
			void freeRestrictions();

			/**
			 * Makes an area restricted.
			 */
			void occupy(int x, int y, int width, int height);

			/**
			 * returns a vector of possible places where to an object with given dimensions / size.
			 */
			std::vector<sf::Vector2<int> > getPossiblePlaces(int width, int height);

			/**
			 * Returns all possible Places in a certain area.
			 */
			std::vector<sf::Vector2<int> > getPossiblePlaces(sf::Vector2<int>, sf::Vector2<int>, sf::Vector2<int>);
			/**
			 * Fill the layer with random walls.
			 * This generates a labyrinth.
			 * @param minLength {int} Minimum length of a wall. This might not always happen.
			 * @param maxLength {int} Maximum length of a wall.
			 * @param granularity {int} Sets the space between the walls.
			 * @param numWalls {int} Maximum amount of walls which will be generated.
			 */
			void fillWithWalls(int minLength, int maxLength, int granularity, int numWalls);
			/**
			 * This will try to add a Wall to the layer, by a given length and position.
			 * @param x {int} x Coordinate
			 * @param y {int} y Coordinate
			 * @param direction {theseus::map::Direction}
			 * @param length {int} maximal Length of the wall.
			 */
			void addWall(int x, int y, Direction direction, int length);

			/**
			 * Creates the gras around the field.
			 */
			void createGras();

			/**
			 * Creates parking areas arount the layer.
			 */
			void createParkingAreas();

		public:
			/**
			 * Initialize a squared layer.
			 * It will work as a generator which interpretes the LevelDescription.
			 */
			Layer(std::unique_ptr<LevelDescription>);
			/**
			 * Transform the layer into a Scene.
			 */
			std::unique_ptr<theseus::engine::Scene> toScene();
			/**
			 * Print the Layer in ASCII art. Only works in Unicode Command Lines.
			 */
			friend std::ostream& operator<<(std::ostream&, const Layer&);
	};
}
}
#endif
